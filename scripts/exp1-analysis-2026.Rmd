---
title: "exp1-p3"
output: html_document
date: "2026-01-04"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source(file = './utils/exp1-utils.R')  # loads all necessary packages 
source(file = './utils/stimuli.R')
source(file = './utils/exp1-analysis-utils.R')
```

# Malagasy dataset
### Analysis of scaled data collection
n = 50

```{r data-load}
dataPath = "data/exp1/csv/2026/"
mgdem = read_csv(paste(dataPath, "mg-dem.csv", sep = ''))
mgdf = read_csv(paste(dataPath, "mg-df.csv", sep = ''))
mgdf_w = read_csv(paste(dataPath, "mg-df-weight.csv", sep = ''))

usdem = read_csv(paste(dataPath, "us-dem.csv", sep = ''))
usdf = read_csv(paste(dataPath, "us-df.csv", sep = ''))
usdf_w = read_csv(paste(dataPath, "us-df-weight.csv", sep = ''))

rm(dataPath)
```

### Analyzing within group
```{r plot assoc. weights}
## Association weight MDG
mgdf_w$con = factor(mgdf_w$concept, levels=conceptListEn3) # to order the facet strips 
p1 <- plotWeight_Err(mgdf_w, "Mean weight of assoc, lib: BCP37, MDG"); p1
  
## Association weight USA
usdf_w$con = factor(usdf_w$concept, levels=conceptListEn3) # to order the facet strips 
p2 <- plotWeight_Err(usdf_w, "Mean weight of assoc., lib: BCP37, USA") + 
  theme(axis.title.y = element_blank(), axis.text.y = element_blank()); p2 

p12 <- grid.arrange(p1, p2, nrow = 1); p12
```

```{r eval=FALSE}
# ggsave(file="./fig/weight-mg.png", plot = p1, width=10, height=16)
# ggsave(file="./fig/weight-us.png", plot = p2, width=10, height=16)
# ggsave(file="./fig/weight-both.png", plot = p12, width=10, height=16)
```

#### Unique pairs of concepts and pairs of colors without repetition 
`without repetition` ie. {red, yellow} == {yellow, red}
```{r}
concept_pairs <- as.data.frame(t(combn(unique(usdf$concept), 2))) %>% rename(concept1 = V1, concept2 = V2)
color_pairs <- as.data.frame(t(combn(unique(mgdf$color), 2))) %>% rename(color1 = V1, color2 = V2)
```

```{r US data}
# Aggregated data (x = average rating for each color of each concept)
usdf_agg <- usdf %>% group_by(concept, color) %>% summarise(xbar = mean(rating), sd_sample = sd(rating), .groups = 'drop')

a_us <- coef(getFitSd(usdf_agg)) # alpha a_us = 1.384426
# Plotting the data points, and fitted curve
plot(usdf_agg$xbar, usdf_agg$sd_sample, main = "Fit for model s = a * xbar * (1 - xbar)",
     xlab = "Mean (xbar)", ylab = "Standard Deviation (s)", pch = 16)
curve(coef(getFitSd(usdf_agg)) * x * (1 - x), add = TRUE, col = "orange", lwd = 2)

a_us2 <- coef(getFitSd2(usdf_agg)) # alpha a = 0.37, beta b = 0.32
plot(usdf_agg$xbar, usdf_agg$sd_sample, main = "Fit for model s = a * xbar^b",
     xlab = "Mean (xbar)", ylab = "Standard Deviation (s)", pch = 16)
curve(coef(getFitSd2(usdf_agg))[1] * x^coef(getFitSd2(usdf_agg))[2], add = TRUE, col = "red", lwd = 2)

# -> The first model w/ a_us fits the data better, so we will use a_us from here
# Note that in the paper, a_us is set to 1.4. Model is s = 1.4 * xbar * (1-xbar)

# xUs <- getXvalues(usdf_agg, concept_pairs, color_pairs, a_us) %>% mutate(deltaX = (xbar1 + xbar4) - (xbar2 + xbar3))
xUs2 <- getXvalues_opt(usdf_agg, concept_pairs, color_pairs, a_us) %>% mutate(deltaX = (xbar1 + xbar4) - (xbar2 + xbar3))

### Verifying if the outputs of getXvalues and getXvalues_opt are the same
###-> Yes, they are the same
# xus <- xUs[order(names(xUs))]; xus <- xus[order(row.names(xus)), ]
# xus2 <- xUs2[order(names(xUs2))]; xus2 <- xus2[order(row.names(xus2)),]
# anti_join(xus, xus2) # if nrow here == 0 then all rows in xus can be found in xus2, i.e. the two df are identical
# nrow(merge(xus, xus2))

deltaS_us <- getDeltaS(xUs2) %>% select(concept1, concept2, color1, color2, deltaS_sample, deltaS_fit)
# mean(deltaS_us$deltaS_sample - deltaS_us$deltaS_fit) ~= -0.007, i.e. the fitted S is correct
```


```{r MG data}
mgdf_agg <- mgdf %>% group_by(concept, color) %>% summarise(xbar = mean(rating), sd_sample = sd(rating), .groups = 'drop')

a_mg <- coef(getFitSd(mgdf_agg)) # a = 1.536
# Plotting the data points, and fitted curve
plot(mgdf_agg$xbar, mgdf_agg$sd_sample, main = "MDG data: Fit for the Function s = a * xbar * (1 - xbar)",
     xlab = "Mean (xbar)", ylab = "Standard Deviation (s)", pch = 16)
curve(coef(getFitSd(mgdf_agg)) * x * (1 - x), add = TRUE, col = "orange", lwd = 2)

a_mg2 <- coef(getFitSd2(mgdf_agg))
plot(mgdf_agg$xbar, mgdf_agg$sd_sample, main = "Fit for model s = a * xbar^b",
     xlab = "Mean (xbar)", ylab = "Standard Deviation (s)", pch = 16)
curve(coef(getFitSd2(mgdf_agg))[1] * x^coef(getFitSd2(mgdf_agg))[2], add = TRUE, col = "red", lwd = 2)

# The first model w/ a_mg fits the data better, so we will use a_mg from here

# xMg <- getXvalues(mgdf_agg, concept_pairs, color_pairs, a_mg) %>% mutate(deltaX = (xbar1 + xbar4) - (xbar2 + xbar3))
xMg2 <- getXvalues_opt(mgdf_agg, concept_pairs, color_pairs, a_mg) %>% mutate(deltaX = (xbar1 + xbar4) - (xbar2 + xbar3))

### Verifying if the outputs of getXvalues and getXvalues_opt are the same (using the same method as in the chunk above)
###-> YES, THEY ARE

deltaS_mg <- getDeltaS(xMg2) %>% select(concept1, concept2, color1, color2, deltaS_sample, deltaS_fit)
```

```{r}
write_csv(deltaS_mg, "output/mg-deltaS.csv")
write_csv(deltaS_us, "output/us-deltaS.csv")

```

```{r cross-cultural analysis}
# Finding four pairs of colors for each pair of concepts such that
## working with deltaS_mg and deltaS_us

dsmg <- deltaS_mg %>% select(-deltaS_sample) %>% rename(deltaSmg = deltaS_fit)
dsus <- deltaS_us %>% select(-deltaS_sample) %>% rename(deltaSus = deltaS_fit)

getPairs <- function(dsL, dsH){
  dsmgL = filter(dsmg, deltaSmg <= dsL) %>% select(-deltaSmg); 
  dsmgH = filter(dsmg, deltaSmg >= dsH) %>% select(-deltaSmg)
  dsusL = filter(dsus, deltaSus <= dsL) %>% select(-deltaSus);
  dsusH = filter(dsus, deltaSus >= dsH) %>% select(-deltaSus)
  
  mgL_usH = inner_join(dsmgL, dsusH, by = c('concept1', 'concept2', 'color1', 'color2')) %>% # common rows between the two dataframes
    rename(mgL_usH1 = color1, mgL_usH2 = color2)
  mgH_usH = inner_join(dsmgH, dsusH, by = c('concept1', 'concept2', 'color1', 'color2')) %>% 
    rename(mgH_usH1 = color1, mgH_usH2 = color2)
  mgL_usL = inner_join(dsmgL, dsusL, by = c('concept1', 'concept2', 'color1', 'color2')) %>% 
    rename(mgL_usL1 = color1, mgL_usL2 = color2)
  mgH_usL = inner_join(dsmgH, dsusL, by = c('concept1', 'concept2', 'color1', 'color2')) %>% 
    rename(mgH_usL1 = color1, mgH_usL2 = color2)
  
  final <- mgL_usH %>%
    full_join(mgH_usH, by = c('concept1', 'concept2'), relationship = "many-to-many") %>%
    full_join(mgL_usL, by = c('concept1', 'concept2'), relationship = "many-to-many") %>%
    full_join(mgH_usL, by = c('concept1', 'concept2'), relationship = "many-to-many")#  %>% drop_na()
  
  return(final)
}

# Lower and Higher thresholds for deltaS
dsL = 0.1; dsH = 0.7
final <- getPairs(dsL, dsH)  %>% drop_na()
unique(final$concept1); unique(final$concept2);

# find which columns of the dataframe only have NAs
names(final)[sapply(final, function(x) sum(is.na(x)) == length(x))]
final <- final %>% filter(!is.na(mgH_usL1), !is.na(mgH_usL2))

# unique combinations of two columns concept1 and concept2
final %>% distinct(concept1, concept2)
final %>% group_by(concept1, concept2) %>% summarize(freq = n())

## Adding color code to Final dataset
bcp37 <- read_csv("utils/color_values_bcp37.csv")# %>% select('name', 'color', 'hex')
```


```{r cross-cultural analysis}
write_csv(final, paste("output/", gsub("\\.", "", dsL), "-", gsub("\\.", "", dsH), "-final.csv", sep = ""))
```


```{r more analysis}
# TODO: a scatterplot of xaxis: min deltaS, yaxis: max deltaS
# scatterplot shows the number of concepts we find for different combination of {min deltaS,max deltaS}

scatterDf <- data.frame()
for (low in c(0.1, 0.2, 0.3)){
  for (hi in c(0.9, 0.8, 0.7)){
    
    tmp <- getPairs(low, hi) 
    
    a <- tmp %>% group_by(concept1, concept2) %>% summarize( 
        n_con_pair = n(), 
        mgL_usL = sum(!is.na(mgL_usL1)), mgL_usH = sum(!is.na(mgL_usH1)), 
        mgH_usL = sum(!is.na(mgH_usL1)), mgH_usH = sum(!is.na(mgH_usH1)), .groups = 'drop')
    
    a$dsLow = low; a$dsHi = hi
    scatterDf <- rbind(scatterDf, a)
  }
}
```

```{r generate data for d3 visualization}
library(jsonlite)

# Sample data (to be replaced with actual data)
# df <- data.frame(
#   concept1 = c("banana", "banana", "test1"),
#   concept2 = c("love", "love", "test2"),
#   mgL_usH1 = c("WH", "SR", "LH1"),
#   mgL_usH2 = c("XR", "MR", "LH2"),
#   mgH_usH1 = c("MG", "WH", "HH1"),
#   mgH_usH2 = c("MR", "MG", "HH2"),
#   mgL_usL1 = c("SR", "MR", "MR"),
#   mgL_usL2 = c("MG", "WH", "MR"),
#   mgH_usL1 = c("WH", "SR", "SR"),
#   mgH_usL2 = c("MR", "MG", "XR"),
#   stringsAsFactors = FALSE
# )

## !!! NOTE The FILTER 
df <- final # %>% filter(mgL_usH1 == "WH", mgL_usH2 == "DP", mgH_usH1=="DG", mgH_usH2 == "BK")

json_list <- list()
for (i in 1:nrow(df)) {
  # Extract values for the current row
  row_data <- df[i, ]
  
  # Define the JSON structure for the current row
  json_data <- list(
    concept1 = row_data$concept1,
    concept2 = row_data$concept2,
    mgL_usH = list(row_data$mgL_usH1, row_data$mgL_usH2),
    mgH_usH = list(row_data$mgH_usH1, row_data$mgH_usH2),
    mgL_usL = list(row_data$mgL_usL1, row_data$mgL_usL2),
    mgH_usL = list(row_data$mgH_usL1, row_data$mgH_usL2))
  json_list[[i]] <- json_data
}

# Convert the entire list to JSON and write it to a single file
json_string <- toJSON(json_list, pretty = TRUE, auto_unbox = TRUE)
# print(json_string)

# write(json_string, file = "output/final-12-2026.json")
write(json_string, file = paste("output/", gsub("\\.", "", dsL), "-", gsub("\\.", "", dsH), "-final.json", sep = ""))

# df2 <- data.frame(
#   color = c("WH", "SR", "MR", "MG", "XR", "LH1", "LH2", "HH1", "HH2"),
#   hex = c("white", "red", "orange", "green", "purple", "lightyellow", "light", "HH1", "HH2"),
#   L = c(100, 70, 40, 30, 0, 0,0,0,0),
#   a = c(0, 70, -70, 0, 0,0,0,0,0),
#   b = c(0, 0, 70, -70, 0,0,0,0,0),
#   stringsAsFactors = FALSE
# )

df2 <- bcp37
# Function to create JSON-like entry for each color (more info about the color)
create_json_entry <- function(code) {
  entry <- df2 %>% filter(color == code)
  if (nrow(entry) > 0) {
    return(list(color = code, hex = entry$hex, L = entry$L, a = entry$a, b = entry$b))
    # return(list(color = code, hex = entry$hex, L = entry$L))
      } else {
    return(NULL)  # Return NULL if the color code doesn't exist in df2
  }
}

# Replace color codes with JSON entries
df_replaced <- df %>%
  mutate(across(starts_with("mg"), ~map(.x, create_json_entry)))

# Convert the transformed dataframe back to JSON
output_json <- toJSON(df_replaced, pretty = TRUE, auto_unbox = TRUE)

# cat(output_json)

df_combined <- df_replaced %>% 
  mutate(mgL_usH = map2(mgL_usH1, mgL_usH2, ~ list(.x, .y))) %>%
  mutate(mgL_usL = map2(mgL_usL1, mgL_usL2, ~ list(.x, .y))) %>%
  mutate(mgH_usH = map2(mgH_usH1, mgH_usH2, ~ list(.x, .y))) %>%
  mutate(mgH_usL = map2(mgH_usL1, mgH_usL2, ~ list(.x, .y))) %>%
  select(-mgL_usH1, -mgL_usH2, -mgL_usL1, -mgL_usL2, -mgH_usH1, -mgH_usH2, -mgH_usL1, -mgH_usL2 )  # Remove the original keys

# Convert the modified dataframe back to JSON
output_json <- toJSON(df_combined, pretty = TRUE, auto_unbox = TRUE)

# Print the resulting JSON
# cat(output_json)
# write(output_json, file = "output/full-12-2026.json")
write(output_json, file = paste("output/", gsub("\\.", "", dsL), "-", gsub("\\.", "", dsH), "-full.json", sep = ""))
```
