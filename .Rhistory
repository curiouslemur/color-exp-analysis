dfus_agg <- dfus %>% group_by(concept, color) %>% summarise(xbar = mean(rating), sd_sample = sd(rating), .groups = 'drop')
a_us <- coef(getFitSd(dfus_agg)) # a = 1.384426
# Plotting the data points, and fitted curve
plot(dfus_agg$xbar, dfus_agg$sd_sample, main = "Fit for model s = a * xbar * (1 - xbar)",
xlab = "Mean (xbar)", ylab = "Standard Deviation (s)", pch = 16)
curve(coef(getFitSd(dfus_agg)) * x * (1 - x), add = TRUE, col = "orange", lwd = 2)
a_us2 <- coef(getFitSd2(dfus_agg))
plot(dfus_agg$xbar, dfus_agg$sd_sample, main = "Fit for model s = a * xbar^b",
xlab = "Mean (xbar)", ylab = "Standard Deviation (s)", pch = 16)
curve(coef(getFitSd2(dfus_agg))[1] * x^coef(getFitSd2(dfus_agg))[2], add = TRUE, col = "red", lwd = 2)
# The first model w/ a_us fits the data better, so we will use a_us from here
# xUs <- getXvalues(dfus_agg, concept_pairs, color_pairs, a_us) %>% mutate(deltaX = (xbar1 + xbar4) - (xbar2 + xbar3))
xUs2 <- getXvalues_opt(dfus_agg, concept_pairs, color_pairs, a_us) %>% mutate(deltaX = (xbar1 + xbar4) - (xbar2 + xbar3))
### Verifying if the outputs of getXvalues and getXvalues_opt are the same
### Yes, they are the same
# xus <- xUs[order(names(xUs))]; xus <- xus[order(row.names(xus)), ]
# xus2 <- xUs2[order(names(xUs2))]; xus2 <- xus2[order(row.names(xus2)),]
# anti_join(xus, xus2) # if nrow here == 0 then all rows in xus can be found in xus2, i.e. the two df are identical
# nrow(merge(xus, xus2))
deltaS_us <- getDeltaS(xUs2) %>% select(concept1, concept2, color1, color2, deltaS_sample, deltaS_fit)
# mean(deltaS_us$deltaS_sample - deltaS_us$deltaS_fit) ~= -0.007, i.e. the fitted S is correct
dfmg_agg <- dfmg %>% group_by(concept, color) %>% summarise(xbar = mean(rating), sd_sample = sd(rating), .groups = 'drop')
a_mg <- coef(getFitSd(dfmg_agg)) # a = 1.536
# Plotting the data points, and fitted curve
plot(dfmg_agg$xbar, dfmg_agg$sd_sample, main = "Fit for the Function s = a * xbar * (1 - xbar)",
xlab = "Mean (xbar)", ylab = "Standard Deviation (s)", pch = 16)
curve(coef(getFitSd(dfmg_agg)) * x * (1 - x), add = TRUE, col = "orange", lwd = 2)
a_mg2 <- coef(getFitSd2(dfmg_agg))
plot(dfmg_agg$xbar, dfmg_agg$sd_sample, main = "Fit for model s = a * xbar^b",
xlab = "Mean (xbar)", ylab = "Standard Deviation (s)", pch = 16)
curve(coef(getFitSd2(dfmg_agg))[1] * x^coef(getFitSd2(dfmg_agg))[2], add = TRUE, col = "red", lwd = 2)
# The first model w/ a_mg fits the data better, so we will use a_mg from here
# xMg <- getXvalues(dfmg_agg, concept_pairs, color_pairs, a_mg) %>% mutate(deltaX = (xbar1 + xbar4) - (xbar2 + xbar3))
xMg2 <- getXvalues_opt(dfmg_agg, concept_pairs, color_pairs, a_mg) %>% mutate(deltaX = (xbar1 + xbar4) - (xbar2 + xbar3))
### Verifying if the outputs of getXvalues and getXvalues_opt are the same
### YES, THEY ARE
# xmg <- xMg[order(names(xMg))]; xmg <- xmg[order(row.names(xmg)), ]
# xmg2 <- xMg2[order(names(xMg2))]; xmg2 <- xmg2[order(row.names(xmg2)),]
# anti_join(xmg, xmg2) # if nrow here == 0 then all rows in xmg can be found in xmg2, i.e. the two df are identical
# nrow(merge(xmg, xmg2))
deltaS_mg <- getDeltaS(xMg2) %>% select(concept1, concept2, color1, color2, deltaS_sample, deltaS_fit)
# Finding four pairs of colors for each pair of concepts such that
#
## working with deltaS_mg and deltaS_us
dsmg <- deltaS_mg %>% select(-deltaS_sample) %>% rename(deltaSmg = deltaS_fit)
dsus <- deltaS_us %>% select(-deltaS_sample) %>% rename(deltaSus = deltaS_fit)
# Lower and Higher thresholds for deltaS
dsL = 0.3; dsH = 0.7
getPairs <- function(dsL, dsH){
dsmgL = filter(dsmg, deltaSmg <= dsL) %>% select(-deltaSmg);
dsmgH = filter(dsmg, deltaSmg >= dsH) %>% select(-deltaSmg)
dsusL = filter(dsus, deltaSus <= dsL) %>% select(-deltaSus);
dsusH = filter(dsus, deltaSus >= dsH) %>% select(-deltaSus)
mgL_usH = inner_join(dsmgL, dsusH, by = c('concept1', 'concept2', 'color1', 'color2')) %>% # common rows between the two dataframes
rename(mgL_usH1 = color1, mgL_usH2 = color2)
mgH_usH = inner_join(dsmgH, dsusH, by = c('concept1', 'concept2', 'color1', 'color2')) %>%
rename(mgH_usH1 = color1, mgH_usH2 = color2)
mgL_usL = inner_join(dsmgL, dsusL, by = c('concept1', 'concept2', 'color1', 'color2')) %>%
rename(mgL_usL1 = color1, mgL_usL2 = color2)
mgH_usL = inner_join(dsmgH, dsusL, by = c('concept1', 'concept2', 'color1', 'color2')) %>%
rename(mgH_usL1 = color1, mgH_usL2 = color2)
final <- mgL_usH %>%
full_join(mgH_usH, by = c('concept1', 'concept2')) %>%
full_join(mgL_usL, by = c('concept1', 'concept2')) %>%
full_join(mgH_usL, by = c('concept1', 'concept2')) %>% drop_na()
return(final)
}
final <- getPairs(0.1, 0.7)
## Adding color code to Final dataset
bcp37 <- read_csv("utils/color_values_bcp37.csv")# %>% select('name', 'color', 'hex')
write_csv(final, "output/final-01-07.csv")
final %>% distinct(concept1, concept2)
a <- final %>% group_by(concept1, concept2) %>% summarize(
freq = n()
); a
df <- final
json_list <- list()
for (i in 1:nrow(df)) {
# Extract values for the current row
row_data <- df[i, ]
# Define the JSON structure for the current row
json_data <- list(
concept1 = row_data$concept1,
concept2 = row_data$concept2,
mgL_usH = list(row_data$mgL_usH1, row_data$mgL_usH2),
mgL_usL = list(row_data$mgL_usL1, row_data$mgL_usL2),
mgH_usH = list(row_data$mgH_usH1, row_data$mgH_usH2),
mgH_usL = list(row_data$mgH_usL1, row_data$mgH_usL2)
)
# Append the JSON structure to the list
json_list[[i]] <- json_data
}
# Convert the entire list to JSON and write it to a single file
json_string <- toJSON(json_list, pretty = TRUE, auto_unbox = TRUE)
print(json_string)
unique(df$mgL_usH1)
unique(df$mgL_usH2)
df <- final %>% filter(mgL_usH1 == "WH", mgL_usH2 == "DC")
unique(final$mgL_usH1)
unique(final$mgL_usH2)
df <- final %>% filter(mgL_usH1 == "WH")
df <- final %>% filter(mgL_usH1 == "WH", mgL_usH2 == "DP")
View(df)
unique(final$mgH_usH1)
df <- final %>% filter(mgL_usH1 == "WH", mgL_usH2 == "DP", mgH_usH1=="DG")
unique(final$mgH_usH2)
df <- final %>% filter(mgL_usH1 == "WH", mgL_usH2 == "DP", mgH_usH1=="DG", mgH_usH2 = "SG")
df <- final %>% filter(mgL_usH1 == "WH", mgL_usH2 == "DP", mgH_usH1=="DG", mgH_usH2 == "SG")
df <- final %>% filter(mgL_usH1 == "WH", mgL_usH2 == "DP", mgH_usH1=="DG", mgH_usH2 == "BK")
View(df)
json_list <- list()
for (i in 1:nrow(df)) {
# Extract values for the current row
row_data <- df[i, ]
# Define the JSON structure for the current row
json_data <- list(
concept1 = row_data$concept1,
concept2 = row_data$concept2,
mgL_usH = list(row_data$mgL_usH1, row_data$mgL_usH2),
mgL_usL = list(row_data$mgL_usL1, row_data$mgL_usL2),
mgH_usH = list(row_data$mgH_usH1, row_data$mgH_usH2),
mgH_usL = list(row_data$mgH_usL1, row_data$mgH_usL2)
)
# Append the JSON structure to the list
json_list[[i]] <- json_data
}
# Convert the entire list to JSON and write it to a single file
json_string <- toJSON(json_list, pretty = TRUE, auto_unbox = TRUE)
print(json_string)
json_list <- list()
for (i in 1:nrow(df)) {
# Extract values for the current row
row_data <- df[i, ]
# Define the JSON structure for the current row
json_data <- list(
concept1 = row_data$concept1,
concept2 = row_data$concept2,
mgL_usH = list(row_data$mgL_usH1, row_data$mgL_usH2),
mgH_usH = list(row_data$mgH_usH1, row_data$mgH_usH2),
mgH_usL = list(row_data$mgH_usL1, row_data$mgH_usL2),
mgL_usL = list(row_data$mgL_usL1, row_data$mgL_usL2),
)
# Append the JSON structure to the list
json_list[[i]] <- json_data
}
df <- final %>% filter(mgL_usH1 == "WH", mgL_usH2 == "DP", mgH_usH1=="DG", mgH_usH2 == "BK")
json_list <- list()
for (i in 1:nrow(df)) {
# Extract values for the current row
row_data <- df[i, ]
# Define the JSON structure for the current row
json_data <- list(
concept1 = row_data$concept1,
concept2 = row_data$concept2,
mgL_usH = list(row_data$mgL_usH1, row_data$mgL_usH2),
mgH_usH = list(row_data$mgH_usH1, row_data$mgH_usH2),
mgH_usL = list(row_data$mgH_usL1, row_data$mgH_usL2),
mgL_usL = list(row_data$mgL_usL1, row_data$mgL_usL2),
)
# Append the JSON structure to the list
json_list[[i]] <- json_data
}
for (i in 1:nrow(df)) {
# Extract values for the current row
row_data <- df[i, ]
# Define the JSON structure for the current row
json_data <- list(
concept1 = row_data$concept1,
concept2 = row_data$concept2,
mgL_usH = list(row_data$mgL_usH1, row_data$mgL_usH2),
mgH_usH = list(row_data$mgH_usH1, row_data$mgH_usH2),
mgH_usL = list(row_data$mgH_usL1, row_data$mgH_usL2),
mgL_usL = list(row_data$mgL_usL1, row_data$mgL_usL2))
# Append the JSON structure to the list
json_list[[i]] <- json_data
}
# Convert the entire list to JSON and write it to a single file
json_string <- toJSON(json_list, pretty = TRUE, auto_unbox = TRUE)
print(json_string)
write(json_string, file = "output.json")
df2 <- data.frame(
color = c("WH", "SR", "MR", "MG", "XR", "LH1", "LH2", "HH1", "HH2"),
hex = c("white", "red", "orange", "green", "purple", "lightyellow", "light", "HH1", "HH2"),
L = c(100, 70, 40, 30, 0, 0,0,0,0),
a = c(0, 70, -70, 0, 0,0,0,0,0),
b = c(0, 0, 70, -70, 0,0,0,0,0),
stringsAsFactors = FALSE
)
# Function to create JSON-like entry
create_json_entry <- function(code) {
entry <- df2 %>% filter(color == code)
if (nrow(entry) > 0) {
return(list(color = code, hex = entry$hex, L = entry$L, a = entry$a, b = entry$b))
# return(list(color = code, hex = entry$hex, L = entry$L))
} else {
return(NULL)  # Return NULL if the color code doesn't exist in df2
}
}
# Replace color codes with JSON entries
df_replaced <- df %>%
mutate(across(starts_with("mg"), ~map(.x, create_json_entry)))
# Convert the transformed dataframe back to JSON
output_json <- toJSON(df_replaced, pretty = TRUE, auto_unbox = TRUE)
cat(output_json)
df_combined <- df_replaced %>%
mutate(mgL_usH = map2(mgL_usH1, mgL_usH2, ~ list(.x, .y))) %>%
mutate(mgL_usL = map2(mgL_usL1, mgL_usL2, ~ list(.x, .y))) %>%
mutate(mgH_usH = map2(mgH_usH1, mgH_usH2, ~ list(.x, .y))) %>%
mutate(mgH_usL = map2(mgH_usL1, mgH_usL2, ~ list(.x, .y))) %>%
select(-mgL_usH1, -mgL_usH2, -mgL_usL1, -mgL_usL2, -mgH_usH1, -mgH_usH2, -mgH_usL1, -mgH_usL2 )  # Remove the original keys
df2 <- bcp37
# Function to create JSON-like entry
create_json_entry <- function(code) {
entry <- df2 %>% filter(color == code)
if (nrow(entry) > 0) {
return(list(color = code, hex = entry$hex, L = entry$L, a = entry$a, b = entry$b))
# return(list(color = code, hex = entry$hex, L = entry$L))
} else {
return(NULL)  # Return NULL if the color code doesn't exist in df2
}
}
# Replace color codes with JSON entries
df_replaced <- df %>%
mutate(across(starts_with("mg"), ~map(.x, create_json_entry)))
# Convert the transformed dataframe back to JSON
output_json <- toJSON(df_replaced, pretty = TRUE, auto_unbox = TRUE)
cat(output_json)
df_combined <- df_replaced %>%
mutate(mgL_usH = map2(mgL_usH1, mgL_usH2, ~ list(.x, .y))) %>%
mutate(mgL_usL = map2(mgL_usL1, mgL_usL2, ~ list(.x, .y))) %>%
mutate(mgH_usH = map2(mgH_usH1, mgH_usH2, ~ list(.x, .y))) %>%
mutate(mgH_usL = map2(mgH_usL1, mgH_usL2, ~ list(.x, .y))) %>%
select(-mgL_usH1, -mgL_usH2, -mgL_usL1, -mgL_usL2, -mgH_usH1, -mgH_usH2, -mgH_usL1, -mgH_usL2 )  # Remove the original keys
# Convert the modified dataframe back to JSON
output_json <- toJSON(df_combined, pretty = TRUE, auto_unbox = TRUE)
# Print the resulting JSON
cat(output_json)
print(json_string)
print(json_string)
json_list <- list()
for (i in 1:nrow(df)) {
# Extract values for the current row
row_data <- df[i, ]
# Define the JSON structure for the current row
json_data <- list(
concept1 = row_data$concept1,
concept2 = row_data$concept2,
mgL_usH = list(row_data$mgL_usH1, row_data$mgL_usH2),
mgH_usH = list(row_data$mgH_usH1, row_data$mgH_usH2),
mgL_usL = list(row_data$mgL_usL1, row_data$mgL_usL2),
mgH_usL = list(row_data$mgH_usL1, row_data$mgH_usL2))
# Append the JSON structure to the list
json_list[[i]] <- json_data
}
# Convert the entire list to JSON and write it to a single file
json_string <- toJSON(json_list, pretty = TRUE, auto_unbox = TRUE)
print(json_string)
write(json_string, file = "output.json")
df2 <- bcp37
# Function to create JSON-like entry
create_json_entry <- function(code) {
entry <- df2 %>% filter(color == code)
if (nrow(entry) > 0) {
return(list(color = code, hex = entry$hex, L = entry$L, a = entry$a, b = entry$b))
# return(list(color = code, hex = entry$hex, L = entry$L))
} else {
return(NULL)  # Return NULL if the color code doesn't exist in df2
}
}
print(json_string)
write(json_string, file = "output/final-01-07.csv")
write(json_string, file = "output/final-01-07.csv")
write(json_string, file = "output/final-01-07.json")
knitr::opts_chunk$set(echo = TRUE)
source(file = './utils/exp1-utils.R')  # loads all necessary packages
# raw data exported from exp1-data-prep.R
dfus = read_csv("data/exp1/csv/clean/p3-us.csv")
dfmg = read_csv("data/exp1/csv/clean/p3-mg.csv") # extra column 'conceptFr' for the concept name in French
# Unique pairs of concepts and colors without repetition
concept_pairs <- as.data.frame(t(combn(unique(dfus$concept), 2))) %>% rename(concept1 = V1, concept2 = V2)
color_pairs <- as.data.frame(t(combn(unique(dfmg$color), 2))) %>% rename(color1 = V1, color2 = V2)
### NOTE ###
# In the paper, the proposed fit as in the paper is: sd = 1.4*xbar*(1 - xbar)
# where xbar is the mean association across all people for this color and concept
###### Fit for function for the sd. Model s = a.xbar.(1-xbar)
# function to get the value of the coeff a
getFitSd <- function(data){
d1 <- data[1,];
a_start = d1$sd_sample / (d1$xbar * (1 - d1$xbar))
fit <- nls( sd_sample ~ a * xbar * (1-xbar), data = data, start = list(a = a_start))
return(fit)
}
## using the sd = a * xbar ^ b model
getFitSd2 <- function(data){
fit <- nls(sd_sample ~ a * xbar^b, data = data, start = list(a = 1, b = 1))
return(fit)
}
# function to get the values for xbars, sd_samples, and sd_fits for each pair of concepts and colors
# the resulting dataframe is a representation of the bigram in the paper
getXvalues <- function(data, concept_pairs, color_pairs, sd_fit_coef){
res <- data.frame()
# Loop through all concept pairs and color pairs to populate the res (for result) dataframe
for (i in 1:nrow(concept_pairs)) {
for (j in 1:nrow(color_pairs)) {
concept1 <- concept_pairs[i, 1]; concept2 <- concept_pairs[i, 2]
color1 <- color_pairs[j, 1]; color2 <- color_pairs[j, 2]
# Combine into a new row
new_row <- data.frame(
concept1 = concept1, concept2 = concept2,
color1 = color1, color2 = color2,
xbar1 = data$xbar[data$concept == concept1 & data$color == color1],
xbar2 = data$xbar[data$concept == concept1 & data$color == color2],
xbar3 = data$xbar[data$concept == concept2 & data$color == color1],
xbar4 = data$xbar[data$concept == concept2 & data$color == color2],
sd_sample1 = data$sd_sample[data$concept == concept1 & data$color == color1],
sd_sample2 = data$sd_sample[data$concept == concept1 & data$color == color2],
sd_sample3 = data$sd_sample[data$concept == concept2 & data$color == color1],
sd_sample4 = data$sd_sample[data$concept == concept2 & data$color == color2]
)
new_row <- mutate(new_row,
sd_fit1 = sd_fit_coef * xbar1 * (1 - xbar1),
sd_fit2 = sd_fit_coef * xbar2 * (1 - xbar2),
sd_fit3 = sd_fit_coef * xbar3 * (1 - xbar3),
sd_fit4 = sd_fit_coef * xbar4 * (1 - xbar4))
# Add the new row to the result dataframe
res <- rbind(res, new_row)
print(nrow(res))
}
}
return(res)
}
# write_csv(xUs, "output/xUs_not_optimized.csv")
## This is by far a more optimized version of the above function
getXvalues_opt <- function(data, concept_pairs, color_pairs, sd_fit_coef){
df1 <- merge(concept_pairs, color_pairs)
# lookup_df = data # %>% select(concept, color, xbar)
extended_DF <- df1 %>%
left_join(data, by = c("concept1" = "concept", "color1" = "color")) %>%
rename(xbar1 = xbar, sd_sample1 = sd_sample) %>%
left_join(data, by = c("concept1" = "concept", "color2" = "color")) %>%
rename(xbar2 = xbar, sd_sample2 = sd_sample) %>%
left_join(data, by = c("concept2" = "concept", "color1" = "color")) %>%
rename(xbar3 = xbar, sd_sample3 = sd_sample) %>%
left_join(data, by = c("concept2" = "concept", "color2" = "color")) %>%
rename(xbar4 = xbar, sd_sample4 = sd_sample)
x_opt <- mutate(extended_DF,
sd_fit1 = sd_fit_coef * xbar1 * (1 - xbar1),
sd_fit2 = sd_fit_coef * xbar2 * (1 - xbar2),
sd_fit3 = sd_fit_coef * xbar3 * (1 - xbar3),
sd_fit4 = sd_fit_coef * xbar4 * (1 - xbar4)) %>% mutate(deltaX = (xbar1 + xbar4) - (xbar2 + xbar3))
return(x_opt)
}
# function to get values of deltaS (either using sd_sample or fitted sd)
getDeltaS <- function(data){
data <- mutate(data,
ProbDelta_sample = pnorm( deltaX / sqrt(sd_sample1^2 + sd_sample2^2 + sd_sample3^2 + sd_sample4^2)),
ProbDelta_fit = pnorm( deltaX / sqrt(sd_fit1^2 + sd_fit2^2 + sd_fit3^2 + sd_fit4^2)))
data <- mutate(data,
deltaS_sample = abs(2 * ProbDelta_sample - 1),
deltaS_fit = abs(2 * ProbDelta_fit - 1))
return(data)
}
# Aggregated data (x = average rating for each color of each concept)
dfus_agg <- dfus %>% group_by(concept, color) %>% summarise(xbar = mean(rating), sd_sample = sd(rating), .groups = 'drop')
a_us <- coef(getFitSd(dfus_agg)) # a = 1.384426
# Plotting the data points, and fitted curve
plot(dfus_agg$xbar, dfus_agg$sd_sample, main = "Fit for model s = a * xbar * (1 - xbar)",
xlab = "Mean (xbar)", ylab = "Standard Deviation (s)", pch = 16)
curve(coef(getFitSd(dfus_agg)) * x * (1 - x), add = TRUE, col = "orange", lwd = 2)
a_us2 <- coef(getFitSd2(dfus_agg))
plot(dfus_agg$xbar, dfus_agg$sd_sample, main = "Fit for model s = a * xbar^b",
xlab = "Mean (xbar)", ylab = "Standard Deviation (s)", pch = 16)
curve(coef(getFitSd2(dfus_agg))[1] * x^coef(getFitSd2(dfus_agg))[2], add = TRUE, col = "red", lwd = 2)
# The first model w/ a_us fits the data better, so we will use a_us from here
# xUs <- getXvalues(dfus_agg, concept_pairs, color_pairs, a_us) %>% mutate(deltaX = (xbar1 + xbar4) - (xbar2 + xbar3))
xUs2 <- getXvalues_opt(dfus_agg, concept_pairs, color_pairs, a_us) %>% mutate(deltaX = (xbar1 + xbar4) - (xbar2 + xbar3))
### Verifying if the outputs of getXvalues and getXvalues_opt are the same
### Yes, they are the same
# xus <- xUs[order(names(xUs))]; xus <- xus[order(row.names(xus)), ]
# xus2 <- xUs2[order(names(xUs2))]; xus2 <- xus2[order(row.names(xus2)),]
# anti_join(xus, xus2) # if nrow here == 0 then all rows in xus can be found in xus2, i.e. the two df are identical
# nrow(merge(xus, xus2))
deltaS_us <- getDeltaS(xUs2) %>% select(concept1, concept2, color1, color2, deltaS_sample, deltaS_fit)
# mean(deltaS_us$deltaS_sample - deltaS_us$deltaS_fit) ~= -0.007, i.e. the fitted S is correct
dfmg_agg <- dfmg %>% group_by(concept, color) %>% summarise(xbar = mean(rating), sd_sample = sd(rating), .groups = 'drop')
a_mg <- coef(getFitSd(dfmg_agg)) # a = 1.536
# Plotting the data points, and fitted curve
plot(dfmg_agg$xbar, dfmg_agg$sd_sample, main = "Fit for the Function s = a * xbar * (1 - xbar)",
xlab = "Mean (xbar)", ylab = "Standard Deviation (s)", pch = 16)
curve(coef(getFitSd(dfmg_agg)) * x * (1 - x), add = TRUE, col = "orange", lwd = 2)
a_mg2 <- coef(getFitSd2(dfmg_agg))
plot(dfmg_agg$xbar, dfmg_agg$sd_sample, main = "Fit for model s = a * xbar^b",
xlab = "Mean (xbar)", ylab = "Standard Deviation (s)", pch = 16)
curve(coef(getFitSd2(dfmg_agg))[1] * x^coef(getFitSd2(dfmg_agg))[2], add = TRUE, col = "red", lwd = 2)
# The first model w/ a_mg fits the data better, so we will use a_mg from here
# xMg <- getXvalues(dfmg_agg, concept_pairs, color_pairs, a_mg) %>% mutate(deltaX = (xbar1 + xbar4) - (xbar2 + xbar3))
xMg2 <- getXvalues_opt(dfmg_agg, concept_pairs, color_pairs, a_mg) %>% mutate(deltaX = (xbar1 + xbar4) - (xbar2 + xbar3))
### Verifying if the outputs of getXvalues and getXvalues_opt are the same
### YES, THEY ARE
# xmg <- xMg[order(names(xMg))]; xmg <- xmg[order(row.names(xmg)), ]
# xmg2 <- xMg2[order(names(xMg2))]; xmg2 <- xmg2[order(row.names(xmg2)),]
# anti_join(xmg, xmg2) # if nrow here == 0 then all rows in xmg can be found in xmg2, i.e. the two df are identical
# nrow(merge(xmg, xmg2))
deltaS_mg <- getDeltaS(xMg2) %>% select(concept1, concept2, color1, color2, deltaS_sample, deltaS_fit)
# Finding four pairs of colors for each pair of concepts such that
#
## working with deltaS_mg and deltaS_us
dsmg <- deltaS_mg %>% select(-deltaS_sample) %>% rename(deltaSmg = deltaS_fit)
dsus <- deltaS_us %>% select(-deltaS_sample) %>% rename(deltaSus = deltaS_fit)
# Lower and Higher thresholds for deltaS
dsL = 0.3; dsH = 0.7
getPairs <- function(dsL, dsH){
dsmgL = filter(dsmg, deltaSmg <= dsL) %>% select(-deltaSmg);
dsmgH = filter(dsmg, deltaSmg >= dsH) %>% select(-deltaSmg)
dsusL = filter(dsus, deltaSus <= dsL) %>% select(-deltaSus);
dsusH = filter(dsus, deltaSus >= dsH) %>% select(-deltaSus)
mgL_usH = inner_join(dsmgL, dsusH, by = c('concept1', 'concept2', 'color1', 'color2')) %>% # common rows between the two dataframes
rename(mgL_usH1 = color1, mgL_usH2 = color2)
mgH_usH = inner_join(dsmgH, dsusH, by = c('concept1', 'concept2', 'color1', 'color2')) %>%
rename(mgH_usH1 = color1, mgH_usH2 = color2)
mgL_usL = inner_join(dsmgL, dsusL, by = c('concept1', 'concept2', 'color1', 'color2')) %>%
rename(mgL_usL1 = color1, mgL_usL2 = color2)
mgH_usL = inner_join(dsmgH, dsusL, by = c('concept1', 'concept2', 'color1', 'color2')) %>%
rename(mgH_usL1 = color1, mgH_usL2 = color2)
final <- mgL_usH %>%
full_join(mgH_usH, by = c('concept1', 'concept2')) %>%
full_join(mgL_usL, by = c('concept1', 'concept2')) %>%
full_join(mgH_usL, by = c('concept1', 'concept2')) %>% drop_na()
return(final)
}
final <- getPairs(0.1, 0.7)
## Adding color code to Final dataset
bcp37 <- read_csv("utils/color_values_bcp37.csv")# %>% select('name', 'color', 'hex')
write_csv(final, "output/final-01-07.csv")
final %>% distinct(concept1, concept2)
a <- final %>% group_by(concept1, concept2) %>% summarize(
freq = n()
); a
library(jsonlite)
# Sample data (replace with your actual data)
# df <- data.frame(
#   concept1 = c("banana", "banana", "test1"),
#   concept2 = c("love", "love", "test2"),
#   mgL_usH1 = c("WH", "SR", "LH1"),
#   mgL_usH2 = c("XR", "MR", "LH2"),
#   mgH_usH1 = c("MG", "WH", "HH1"),
#   mgH_usH2 = c("MR", "MG", "HH2"),
#   mgL_usL1 = c("SR", "MR", "MR"),
#   mgL_usL2 = c("MG", "WH", "MR"),
#   mgH_usL1 = c("WH", "SR", "SR"),
#   mgH_usL2 = c("MR", "MG", "XR"),
#   stringsAsFactors = FALSE
# )
df <- final %>% filter(mgL_usH1 == "WH", mgL_usH2 == "DP", mgH_usH1=="DG", mgH_usH2 == "BK")
json_list <- list()
for (i in 1:nrow(df)) {
# Extract values for the current row
row_data <- df[i, ]
# Define the JSON structure for the current row
json_data <- list(
concept1 = row_data$concept1,
concept2 = row_data$concept2,
mgL_usH = list(row_data$mgL_usH1, row_data$mgL_usH2),
mgH_usH = list(row_data$mgH_usH1, row_data$mgH_usH2),
mgL_usL = list(row_data$mgL_usL1, row_data$mgL_usL2),
mgH_usL = list(row_data$mgH_usL1, row_data$mgH_usL2))
# Append the JSON structure to the list
json_list[[i]] <- json_data
}
# Convert the entire list to JSON and write it to a single file
json_string <- toJSON(json_list, pretty = TRUE, auto_unbox = TRUE)
print(json_string)
write(json_string, file = "output/final-01-07.json")
# df2 <- data.frame(
#   color = c("WH", "SR", "MR", "MG", "XR", "LH1", "LH2", "HH1", "HH2"),
#   hex = c("white", "red", "orange", "green", "purple", "lightyellow", "light", "HH1", "HH2"),
#   L = c(100, 70, 40, 30, 0, 0,0,0,0),
#   a = c(0, 70, -70, 0, 0,0,0,0,0),
#   b = c(0, 0, 70, -70, 0,0,0,0,0),
#   stringsAsFactors = FALSE
# )
df2 <- bcp37
# Function to create JSON-like entry
create_json_entry <- function(code) {
entry <- df2 %>% filter(color == code)
if (nrow(entry) > 0) {
return(list(color = code, hex = entry$hex, L = entry$L, a = entry$a, b = entry$b))
# return(list(color = code, hex = entry$hex, L = entry$L))
} else {
return(NULL)  # Return NULL if the color code doesn't exist in df2
}
}
# Replace color codes with JSON entries
df_replaced <- df %>%
mutate(across(starts_with("mg"), ~map(.x, create_json_entry)))
# Convert the transformed dataframe back to JSON
output_json <- toJSON(df_replaced, pretty = TRUE, auto_unbox = TRUE)
cat(output_json)
df_combined <- df_replaced %>%
mutate(mgL_usH = map2(mgL_usH1, mgL_usH2, ~ list(.x, .y))) %>%
mutate(mgL_usL = map2(mgL_usL1, mgL_usL2, ~ list(.x, .y))) %>%
mutate(mgH_usH = map2(mgH_usH1, mgH_usH2, ~ list(.x, .y))) %>%
mutate(mgH_usL = map2(mgH_usL1, mgH_usL2, ~ list(.x, .y))) %>%
select(-mgL_usH1, -mgL_usH2, -mgL_usL1, -mgL_usL2, -mgH_usH1, -mgH_usH2, -mgH_usL1, -mgH_usL2 )  # Remove the original keys
# Convert the modified dataframe back to JSON
output_json <- toJSON(df_combined, pretty = TRUE, auto_unbox = TRUE)
# Print the resulting JSON
cat(output_json)
# Print the resulting JSON
cat(output_json)
write(output_json, file = "output/full.json")
unique(df$mgH_usL2)
