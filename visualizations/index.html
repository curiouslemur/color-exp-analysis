<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3.js Matrix Without Dropdown</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }

        svg {
            display: block;
            background-color: #ffffff;
            padding-top: 20px;
            padding-bottom: 20px;
        }

        .remove-button {
            font-size: 10px;
            padding: 2px 4px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <button id="duplicateButton">Add Grid</button>
    <svg id="svgCanvas"></svg>
    <script src="scripts.js"></script>
    <script>
        d3.json("data/sample-full.json").then(function (data) {
            const matrixSize = 250;
            const padding = 40;
            const svgPadding = 0.03;
            const leftPadding = 20;
            const svgWidth = window.innerWidth * (1 - svgPadding);
            const initialSvgHeight = window.innerHeight;
            const svg = d3.select("#svgCanvas")
                .attr("width", svgWidth)
                .attr("height", initialSvgHeight);

            function drawMatrix(id, xOffset, yOffset, data) {
                const group = svg.append("g")
                    .attr("class", "matrix-group")
                    .attr("id", `matrix-group-${id}`)
                    .attr("transform", `translate(${xOffset + leftPadding}, ${yOffset})`);

                draw_empty_matrix(group, matrixSize);

                const squareSize = matrixSize / 5;
                const squarePaddingX = (matrixSize / 2 - 2 * squareSize) / 3;
                const squarePaddingY = ((matrixSize / 2) - squareSize) / 1.5;

                function createColorPatch(x, y, color, id, concept) {
                    group.append("rect")
                        .attr("x", x).attr("y", y)
                        .attr("width", squareSize).attr("height", squareSize)
                        // .attr("fill", color)
                        .attr("fill", d3.lab(color.L, color.a, color.b))
                        .attr("class", "color-patch")
                        .attr("id", id);
                    group.append("text")
                        .attr("x", x + squareSize / 2).attr("y", y + squareSize + 10)
                        .attr("text-anchor", "middle").attr("dominant-baseline", "central")
                        .attr("fill", "").attr("font-size", 12)
                        .text(concept);
                }

                randRow = data[Math.floor(Math.random() * data.length)]
                console.log(randRow)
                const patchData = [
                    { x: squarePaddingX, y: squarePaddingY, color: randRow["mgL_usH"][0], id: "mgL_usH1", concept: randRow.concept1 },
                    { x: 2 * squarePaddingX + squareSize, y: squarePaddingY, color: randRow["mgL_usH"][1], id: "mgL_usH2", concept: randRow.concept2 },
                    { x: 4 * squarePaddingX + 2 * squareSize, y: squarePaddingY, color: randRow["mgH_usH"][0], id: "mgH_usH1", concept: randRow.concept1 },
                    { x: 5 * squarePaddingX + 3 * squareSize, y: squarePaddingY, color: randRow["mgH_usH"][1], id: "mgH_usH2", concept: randRow.concept2 },
                    { x: squarePaddingX, y: 3 * squarePaddingY + squareSize / 2, color: randRow["mgL_usL"][0], id: "mgL_usL1", concept: randRow.concept1 },
                    { x: 2 * squarePaddingX + squareSize, y: 3 * squarePaddingY + squareSize / 2, color: randRow["mgL_usL"][1], id: "mgL_usL2", concept: randRow.concept2 },
                    { x: 4 * squarePaddingX + 2 * squareSize, y: 3 * squarePaddingY + squareSize / 2, color: randRow["mgH_usL"][0], id: "mgH_usL1", concept: randRow.concept1 },
                    { x: 5 * squarePaddingX + 3 * squareSize, y: 3 * squarePaddingY + squareSize / 2, color: randRow["mgH_usL"][1], id: "mgH_usL2", concept: randRow.concept2 }
                ];

                patchData.forEach(patch => createColorPatch(patch.x, patch.y, patch.color, patch.id, patch.concept));

                group.append("foreignObject")
                    .attr("x", 0)
                    .attr("y", matrixSize + 25)
                    .attr("width", 70)
                    .attr("height", 30)
                    .append("xhtml:button")
                    .attr("class", "remove-button")
                    .text("Remove")
                    .on("click", () => {
                        group.remove();
                        updateMatrixPositions();
                    });
            }

            let matrixCounter = 0;
            let nPerRow = Math.floor(svgWidth / (matrixSize + padding));
            drawMatrix(matrixCounter++, 0, 0, data);

            d3.select("#duplicateButton").on("click", () => {
                const numMatrices = d3.selectAll(".matrix-group").size();
                let newOffsetX = (numMatrices % nPerRow) * (matrixSize + padding);
                const newOffsetY = Math.floor(numMatrices / nPerRow) * (matrixSize + padding + 15);

                drawMatrix(matrixCounter++, newOffsetX, newOffsetY, data);
                updateSvgHeight();
            });

            function updateMatrixPositions() {
                d3.selectAll(".matrix-group").each(function (d, i) {
                    const newXOffset = (i % nPerRow) * (matrixSize + padding);
                    const newYOffset = Math.floor(i / nPerRow) * (matrixSize + padding);
                    d3.select(this).attr("transform", `translate(${newXOffset + leftPadding}, ${newYOffset})`);
                });
                updateSvgHeight();
            }

            function updateSvgHeight() {
                const numMatrices = d3.selectAll(".matrix-group").size();
                const newSvgHeight = Math.ceil(numMatrices / nPerRow) * (matrixSize + padding) + 20;
                svg.attr("height", newSvgHeight);
            }

            window.addEventListener('resize', () => {
                const newSvgWidth = window.innerWidth * (1 - svgPadding);
                svg.attr("width", newSvgWidth);
                nPerRow = Math.floor(newSvgWidth / (matrixSize + padding));
                updateMatrixPositions();
            });
        });
    </script>
</body>

</html>